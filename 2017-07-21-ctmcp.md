---
published: false
title: Concepts, Techniques, and Models of Computer Programming
categories: [Technology]
tags: [Books, CTMCP, Log]
---

8月中に読み終えたい

## 環境構築
- 筆者がメーリスで[こう](https://groups.google.com/forum/#!topic/mozart-users/AilSIdmcB_k)言ってるのでMozart1.4の環境を構築。
- 32bit向けなのでubuntu16.04(32bit)上に構築
- installは[公式のgithub](https://github.com/mozart/mozart)に従った

## 感想log
### はじめに
- めっちゃ感銘を受けた。
- あとでもう一度読んでまとめる
#### 引用
- コンピュータプログラミングの学習法は多数
        
        - プログラミング言語を学ぶのはそのうちの一つ -> 多すぎて全部学ぶのは現実的ではない
- プログラミングは統合的な学問
- 言語ではなくプログラム上の概念にフォーカス
        
        - 計算モデルに基づいて整理(役に立つ計算モデルは言語に比べたら非常に少ない)
- 計算モデル(computation model)
        
        - プログラミングパラダイムという曖昧な概念を精密化したもの 
        - 計算がどうのように行われるかを定義する形式的体系
        - 定義は多数存在するが、プログラマにとっての実用性を重視
        - これに応じて、プログラムするための技法の集合とプログラムに関する推論の集合が決まる
- プログラミングパラダイム
        
        - 敢えて？あいまいなので本書ではメインには触れなそう
- プログラミングモデル
        
        - 計算モデルによって可能となるプログラミング技法と設計原則を指す
- この本に出てくるどの計算モデルも核言語と呼ばれる簡単な中核的言語に基づいている。
- 核言語(kernel language)
        
        - プログラム上の概念のプリミティヴっぽい
        - ex. 関数型プログラミング + 破壊的代入(explicit state) = オブジェクト指向プログラミングが可能
- 概念の追加は創造的拡張原則
        
        - まだ腑に落ちてない
        - 解こうとする問題に関係のない、技術的な理由からプログラムが面倒になる時に追加
        - 入念に選ばれた核言語なら、プログラムの単純さを保てる
        - 利点は同じプログラムの中で異なるモデルが使えること(マルチパラダイムプログラミングと呼ばれる)
        - Lisp, Schemeの設計者も近い思想らしい

- 本書の目的
        
        - プログラミングが統合的な学問である、ということを教えること
        - ソフトウェアシステムの構築が主眼
                
                - システム仕様と実装するプログラムとの間のステップがプログラミング
- プログラミング
       
        - 科学であり技術である
                
                - 科学とは、それによってプログラミングの理解を可能にする予言能力を持つ広く深い理論
                - 技術とは、プログラムの実行を可能にするツール、実用的技法、及び規格
                - 技術(現在のツール)を知ることは、現在に対する備え
                - 科学(基礎的概念)を知ることは将来の発展に対する備え

        - 一般的な人間の行為、すなわち、システムの機能を拡張あるいは変更する行為と定義
        - 非専門家(消費者)及び専門家によって行われる広範囲にわたる行為
        - プログラムのアーキテクチャと抽象を設計することとそれらをコード化すること
                
                - 前者は言語に関係しない、後者は言語に関係する
        - 新たな木亭を達成するために抽象を設計し、使用すること(抽象は融通性をもつ)

- プログラミングはまず間違いなく小手先仕事として教えられる
        
        - その時選ばれた言語に含まれる基礎概念と歴史的偶然が密接にないまぜになっており分離困難
        - パラダイムと呼ばれるプログラミングの異なる見方に基づく、考え方の異なる流派がはびこっている
- プログラミングに広い科学的基盤を与える方法
        
        - 核言語(本書はこれに基づく)
                
                - うまく概念を独立させれば残りの3つを包含したものになりうる
        - 基本的計算理論(λ計算やπ計算など)
                
                - 数学的解析向け
                - 最小個数要素に分解
                - 理論偏重で研究向け
        - 仮想マシン
                
                - ハードウェアと密接した概念の検証向け？
        - マルチパラダイム言語
                
                - ex. Scheme 関数型かつ命令的
                - ex. Leda 関数型、オブジェクト指向的, かつ論理型
                - 有用性は異なるパラダイムがいかに融合してるかに依存
- 抽象
        
        - 抽象を構築する素材であるプログラミング概念から始める。
        - 直列抽象、並列抽象、分散抽象
        - 一般的法則
- Ozによる形式化のみ

        - 本書で出てくる計算モデルはすべて、Ozのサブセット
- Ozを選んだ理由
        
        - 核言語方式に従っているらしい。
        - Mozartの存在
- 概念が増えて良くなる(悪くなるわけではなく、違ったものになるだけである)
        
        -  適材適所、トレードオフ
- 1つのプログラムの中でいくつかのモデルを使いたくなるのはなぜか？

        - 人は計算モデルを使ってプログラムするわけではなく、プログラミング概念とそれらを結合する方法を使ってプログラムするから
        - 計算モデルは一種の付帯現象
        - よくできたプログラムに異なるモデルが含まれるのは自然

- プログラミングという学問の核となる主題
        - 概念と技法
        - データ構造とアルゴリズム
        - プログラム設計とソフトウェアエンジニアリング

- 並列性の取り扱い
        - 状態あり並列性
        - 宣言的並列性

## 思ったこと
- 特定の言語のこの本的な立ち位置を残しとくべきっぽい
- 核言語、概念リスト、計算モデル要りそう

### 1章 プログラミング概念入門(Ozにおける話っぽいな)
#### 変数(variable)
- identifier
        
        - 先頭は大文字
- store variable

#### 関数(function)
- 関数が変数にbindされる
- 引数は局所変数

#### 式(expression)
- if expression
        
        - if (condition) then ~ else ~ end

#### 再帰(recursion)
- 定義しようとしている関数内でその関数を呼び出すこと

#### 無限(任意)精度(infinite precision)
- システムのメモリ量に制限される

#### 関数抽象(functional abstraction)
- 抽象を構成するときに関数を使用すること
- プログラムは関数の層に関数を重ねた玉ねぎのようなもの

#### リスト(list)
- 歴史的理由により空リストはnilと記述
- [5 6 7 8]は略記
- リストはlink-chain
- リストは1時に1要素が生成
- nilから始まり、linkが1つずつ付け加えられる
- 新link
        
        - H|T
        - Hは新要素, Tは旧link
- リンクH|Tは"cons"と呼ばれる(Lisp由来), list-pairとも呼ばれる
        
        - HとTをconsする(consing)と新しいlistになる
        - | は論理型プログラミング言語であるProlog由来

#### パターンマッチング(case文)
- 2つの局所変数を宣言
- パターンに用いられる変数はcase文内のみ

#### トップダウンソフトウェア開発
- 補助関数を予めメイン関数宣言時に宣言しあるものとしてコードをかく
