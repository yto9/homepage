---
title: lower software layer meetup 
published: false
categories: [Technology]
tags: [OS]
---

* Don't remove this line
{:toc}
## meetupについて
### 経緯
![](/assets/img/gline.png)

**完全に腹落ち**・**最終的**・**全体像**から，  
このmeetup内の理解で既存の情報システムの大部分を**大局的に**把握出来るように，  
あまり一般的なソフトウェアプログラマが意識していないであろうトピックを選びました．  

### 目的
パソコンと仲良くなる．

### メイントピック
**コンピュータ****プログラム**の**実行**  


このシンプルな一文について，掘り下げていく(掘り下げられるようにする)．  

このトピックに沿って，情報システムを概観し，  
meetupが終わった時に，少しでも皆さんのディジタルワールドの解像度が上がればいいなと思って話します．

プログラムの実行に**CPU**・**OS**がどのように関わっているかをメインに据えます．


#### 注
今日扱う話は死ぬほど広範囲に渡る話です．
学問領域で言うと，
- コンピュータアーキテクチャ
- ディジタル回路設計
- 論理回路
- 電子回路
- (OS)

辺りに触れます．
定義・証明まみれにならないように敢えて専門用語を避けたり抽象的に話します．


### 情報システムの複雑性と簡便性
情報システムは，ハードウェア，ソフトウェアのそれぞれが複数の階層に別れています．  
その各層のインターフェースが各層のモジュールの汎用性を保つように設計されたことにより，それぞれの層で多数の概念が生まれ，それぞれが学問の一分野になるほど発展しています．
情報システム界全体の複雑さは各層での各モジュールの組み合わせです．
情報システムは各層の実装ではなく，使い方(インターフェース)さえ分かればどんな高度な技術でも利用できます，優しいセカイ．

## コンピュータプログラムの実行

コンピュータプログラムの実行のイメージは人によって違うと思います． 

スマホアプリ・Word・エディタ・ブラウザ・シェル・OS・… ，全てコンピュータプログラムです．  
アプリケーションが起動している時，そのアプリケーションのプログラムは実行されているといいます．

今日は折角低レイヤー勉強会なので，意識されることの少ない(必ずしも意識する必要はない)ブラックボックスの内側に目を向けてみましょう．

### 実行するのはだれか
今回は，  

**コンピュータ**がプログラムを実行する  

としましょう．  
ex. スマホアプリの場合
- 人がアプリをタッチ
- タッチをスマホのOSが検知
- OSがコンピュータにアプリの実行を指示
- コンピュータがアプリを実行

このように任意のプログラムは，"最終的に"コンピュータが実行します．

### 命令セット
人が何かを実行する場合，
- 食べる
- 考える
- 寝る
- etc...

のようにバリエーションは多岐にわたります．

コンピュータの場合はどうでしょうか．

実は，出来る行動(処理)が予め決まっています．
これを，**命令セット**と言います．

### 我々の使用しているコンピュータ
普段接しているコンピュータがどういったものなのか考えてみましょう．

- ディジタルコンピュータ
- ノイマン型コンピュータ

ノイマン型は聞いたことがない人もいるかもしれないが，  
記述されたプログラムを実行するという形式をとっているコンピュータはノイマン型です．

コンピュータをノイマン型コンピュータと認識することで初めて，ソフトウェアという概念が出てきます．

cf.非ノイマン型コンピュータ


**コンピュータ**がプログラムを実行する  
\-> (updated)**CPU**が**メモリ**上にあるプログラムを実行する

## CPUの言語
### バイナリ(binary)

バイナリという単語は，2進数による表示形式を指す場合と，テキストファイル以外を指す場合があるようです．

### CPUが扱えるものはバイナリのみ
- ファイル

        - データ(動画，音声，テキスト, …)
- OS (検証・後述)
- etc..

ほんとに？
### テキストは人間用
普段書いてるプログラムはtextだ！  

\-> 見てみよう

### プログラミング言語と処理系
#### demo
- text
- Cprogram
- object file
- 実行ファイル


### ノイマン型の特徴
ノイマン型は演算器，記憶装置，ソフトウエアと切り分けが明確であり，それぞれの専業が分担して開発できる．
インターフェースさえ画定されていれば，それぞれの分野で独自の技術的発展が可能である






ここまではソフトウェア側からハードウェアとのインターフェースを見てきました．

次はハードウェアからソフトウェアとのインターフェースを見てみましょう．


## ハードウェアから見えるセカイ
### 基本原則
- 入力
- 演算
- 出力

### なんでディジタルなのか
- ベースとなる論理回路は死ぬほど単純 -> 設計が容易
- 論理回路を実装するロジックで最強なのがトランジスタ(小さくて高速低燃費)
- ディジタルコンピュータは情報のディジタル化を促進する 

### 設計の容易さ
論理回路 完全性 検索
- AND 
- OR 
- NOT

の組み合わせで任意のn入力論理回路を設計できる．

         
### 論理回路はトランジスタによって電子回路として実装される




ここまでの話でコンピュータはプログラムの実行が出来る．  
しかし，このままでは，一つのプログラムが終わるまで他のプログラムが実行できない．

今日はここまでかな
## OSの役割
- コンビニとしてのOS
        - 計算機資源の抽象化
                - 生のハードウェアは利用困難
                - 簡便に使えるように関数群を提供 -> システムコールを呼び出すだけ
        - 計算機資源の仮想化
                - CPUやメモリを他のプログラムを意識せず使える
- 警察としてのOS
        - プロセスの隔離
                - 他のプログラムがデータを盗んだり破壊したりしない． 
        - 計算機資源の管理
                - 一つのプログラムがCPUやメモリを独占できないようにする <- システムコールからしかアクセスできない

### 特権
入出力と一部のメモリ領域へのアクセス命令はCPUの特権モードでしか使えない


### CPUを仮想化:スレッド・プロセス
物理的なCPUは十個程度
        - 数百のプログラムを立ち上げることが出来る
### スレッド
OSはスレッドにCPUを割り当て実行
OSが交互に実行
### プロセス

